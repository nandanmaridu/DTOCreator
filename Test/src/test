#!/bin/bash

# Check if exactly 3 arguments are passed
if [ "$#" -ne 3 ]; then
    echo "Usage: sh $0 <string> <list1> <list2>"
    echo "Example: sh $0 CIT \"test1,test2,test3\" \"01,02,03\""
    exit 1
fi

# Assign inputs
main_string="$1"
list1="$2"
list2="$3"

# Convert comma-separated strings into arrays
IFS=',' read -ra array1 <<< "$list1"
IFS=',' read -ra array2 <<< "$list2"

# Check if the two lists are of the same length
if [ "${#array1[@]}" -ne "${#array2[@]}" ]; then
    echo "Error: List lengths do not match."
    exit 1
fi

# Print output
for i in "${!array1[@]}"; do
    echo "$main_string - ${array1[$i]} - ${array2[$i]}"
done


I wanted to provide a quick update regarding a recent issue that briefly impacted the GFX workflow in production.

Earlier today, we introduced a new column to one of our database tables as part of ongoing improvements to support the liquidity workflow. The column was added with a NOT NULL constraint and was successfully validated during liquidity workflow testing.

However, post-deployment, we observed that the GFX workflow began encountering issues when inserting new records. This was due to the JPA layer attempting to write null to the newly added column—behavior not encountered during liquidity workflow testing.

Upon identifying the root cause, we promptly removed the NOT NULL constraint on the new column. This change resolved the issue, and both liquidity and GFX workflows are now functioning as expected in production.

We’re also reviewing our test coverage and deployment checks to help prevent similar scenarios in the future.
